# -*- coding: utf-8 -*-
"""Copy of DiabetesMelitusDNAsequencesKNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TAX3Xf6I5opZE1H2g0dws8Mpo2HQi_j2

IMPORT LIBRARY
"""

# Import Library
import joblib
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import train_test_split

"""DATASET"""

# Muat dataset dari file CSV
data = pd.read_csv('data.csv')
data

data

"""CEK OUTLIER DATA"""

# Memeriksa apakah ada karakter selain A, C, G, T dalam kolom DNA_sequence
invalid_dna = data[~data['sequence'].str.upper().str.contains('^[ACGT]+$')]

# Tampilkan baris-baris dengan nilai yang tidak valid
invalid_dna

duplikat = data[data.duplicated()]
duplikat

# Jumlah Outlier Data
jumlah_invalid_dna = len(invalid_dna)
print(jumlah_invalid_dna)

"""K-MERS"""

# Buat fungsi untuk mengonversi sequence DNA menjadi K-mer
def get_kmers(sequence, size=3):
    """Menghasilkan K-mers dari sequence DNA."""
    return [sequence[i:i+size].upper() for i in range(len(sequence) - size + 1)]

# Terapkan K-mer ke kolom 'sequence'
data['kmers'] = data['sequence'].apply(lambda x: get_kmers(x))
data['kmers']

# Gabungkan semua K-mers menjadi satu string per baris
data['kmers_joined'] = data['kmers'].apply(lambda x: ' '.join(x))
data['kmers_joined']

"""Vectorizer"""

# Use Count Vectorizer for K-mers results
vectorizer = CountVectorizer(ngram_range=(1, 1))
x_kmers = vectorizer.fit_transform(data['kmers_joined'])

# Convert the sparse matrix to DataFrame with feature names as columns
x_kmers_df = pd.DataFrame(x_kmers.toarray(), columns=vectorizer.get_feature_names_out())
x_kmers_df

# Pisahkan fitur dan label (kolom 'class')
y = data['class']
y.value_counts()

"""OVERSAMPLING"""

# Terapkan SMOTE untuk Oversampling
ros = SMOTE(random_state=42)
x_resampled, y_smote = ros.fit_resample(x_kmers_df, y)
y_smote.value_counts()

"""Scaler"""

scaler = MinMaxScaler()
x_scaled = scaler.fit_transform(x_resampled)

# Create a DataFrame from the scaled NumPy array, using original column names
x_scaled_df = pd.DataFrame(x_scaled, columns=x_kmers_df.columns)

# Display the DataFrame
x_scaled_df

"""LABEL ENCODER"""

# Pastikan y adalah array 1D
encoder = LabelEncoder()
y_encoded = encoder.fit_transform(y_smote.values.ravel())  # Ubah DataFrame ke array numpy dan ratakan

# Buat DataFrame dengan kelas dan numeriknya
class_mapping = pd.DataFrame({
    'Class': encoder.classes_,
    'Numeric': encoder.transform(encoder.classes_)
})

# Tampilkan DataFrame dalam bentuk tabel
class_mapping

# Split data
x_train, x_test, y_train, y_test = train_test_split(x_scaled, y_encoded, random_state=42, stratify=y_encoded)

"""MODELING"""

# Inisialisasi dan latih model KNN
model = KNeighborsClassifier()
model.fit(x_train, y_train)

# Prediksi pada data uji
y_pred = model.predict(x_test)

"""EVALUASI"""

# Evaluasi model
print("Laporan Klasifikasi:\n", classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

# Simpan model ke file model.pkl
joblib.dump(model, 'model.pkl')
joblib.dump(vectorizer, 'vectorizer.pkl')
joblib.dump(scaler, 'scaler.pkl')
joblib.dump(encoder, 'encoder.pkl')